# Vector конфигурация для сбора Docker логов и отправки в Seq
# Vector читает логи из Docker контейнеров через Docker API и отправляет в Seq в формате CLEF

[sources.docker_logs]
type = "docker_logs"
# Собираем логи со всех контейнеров, кроме самого Vector
exclude_containers = ["gafus-vector"]
# Docker socket уже смонтирован в контейнер (/var/run/docker.sock)

# Парсинг Docker логов и извлечение метаданных
[transforms.parse_docker_json]
type = "remap"
inputs = ["docker_logs"]
source = '''
  # docker_logs source автоматически предоставляет метаданные:
  # - .container_name (имя контейнера из Docker) 
  # - .container_id (ID контейнера)
  # - .message (содержимое лога - уже распарсено из Docker JSON формата)
  # - .source_type = "stdout" или "stderr"
  # - .timestamp (время события)
  
  # Извлекаем имя контейнера из метаданных Docker (уже есть!)
  if exists(.container_name) && .container_name != null {
    .container_name = string!(.container_name)
  }
  
  # Извлекаем container_id из метаданных
  if exists(.container_id) && .container_id != null {
    .container_id = string!(.container_id)
  }
  
  # Парсим сообщение - docker_logs уже распарсил JSON формат Docker
  # .message содержит текст лога (уже извлечен из {"log":"...", "stream":"...", "time":"..."})
  if exists(.message) {
    .log = string!(.message)
  } else {
    .log = ""
  }
  
  # Определяем stream из source_type
  if exists(.source_type) && .source_type != null {
    .stream = string!(.source_type)
  } else {
    .stream = "stdout"
  }
  
  # Используем timestamp из метаданных (уже timestamp тип) или текущее время
  if !exists(.timestamp) {
    .timestamp = now()
  }
  # Сохраняем timestamp как строку для дальнейшего использования
  current_time = now()
  if exists(.timestamp) {
    .timestamp_str, ts_err = to_string(.timestamp)
    if ts_err != null {
      .timestamp_str = to_string(current_time)
    }
  } else {
    .timestamp_str = to_string(current_time)
  }
  
  .original_message = .message
'''

# Парсинг Pino JSON логов (если log содержит JSON)
[transforms.parse_pino]
type = "remap"
inputs = ["parse_docker_json"]
source = '''
  # Пытаемся распарсить log как Pino JSON
  if exists(.log) && .log != null {
    log_str = string!(.log)
    pino_parsed, pino_err = parse_json(log_str)
    if pino_err == null {
      # Pino логи имеют структуру: {"level": 30, "time": ..., "msg": "...", "app": "...", "context": "..."}
      # Нормализуем уровень лога
      pino_level_num = if exists(pino_parsed.level) { int!(pino_parsed.level) } else { 30 }
      if pino_level_num == 10 {
        .level = "trace"
      } else if pino_level_num == 20 {
        .level = "debug"
      } else if pino_level_num == 30 {
        .level = "info"
      } else if pino_level_num == 40 {
        .level = "warn"
      } else if pino_level_num == 50 {
        .level = "error"
      } else if pino_level_num == 60 {
        .level = "fatal"
      } else {
        .level = "info"
      }
      
      # Извлекаем поля из Pino
      .app = if exists(pino_parsed.app) { string!(pino_parsed.app) } else { null }
      .context = if exists(pino_parsed.context) { string!(pino_parsed.context) } else { null }
      .msg = if exists(pino_parsed.msg) { string!(pino_parsed.msg) } else if exists(pino_parsed.message) { string!(pino_parsed.message) } else { string!(.log) }
      
      # Сохраняем stack trace если есть
      if exists(pino_parsed.err) && exists(pino_parsed.err.stack) {
        .stack = string!(pino_parsed.err.stack)
      } else if exists(pino_parsed.stack) {
        .stack = string!(pino_parsed.stack)
      }
    } else {
      # Не Pino JSON - используем log как есть
      .level = "info"
      .msg = string!(.log)
    }
  } else {
    .level = "info"
    .msg = string!(.original_message)
  }
  
  # Добавляем метки для Seq
  .environment = "production"
  .tag_container_logs = "true"
  
  # Используем timestamp_str из предыдущего transform, или текущее время
  if !exists(.timestamp_str) {
    current_time = now()
    if exists(.timestamp) {
      .timestamp_str, ts_err = to_string(.timestamp)
      if ts_err != null {
        .timestamp_str = to_string(current_time)
      }
    } else {
      .timestamp_str = to_string(current_time)
    }
  }
'''

# Определяем имя контейнера по container_id через простой lookup маппинг
[transforms.add_container_name]
type = "remap"
inputs = ["parse_pino"]
source = '''
  # Сначала пытаемся использовать поле App из Pino (для наших приложений)
  if exists(.app) {
    app_name, err = string(.app)
    if err == null && app_name != null {
      # Маппинг приложений на имена контейнеров
      if app_name == "web" {
        .container_name = "gafus-web"
      } else if app_name == "trainer-panel" {
        .container_name = "gafus-trainer-panel"
      } else if app_name == "error-dashboard" {
        .container_name = "gafus-error-dashboard"
      } else if app_name == "admin-panel" {
        .container_name = "gafus-admin-panel"
      } else if app_name == "worker" {
        .container_name = "gafus-worker"
      } else if app_name == "telegram-bot" {
        .container_name = "gafus-telegram-bot"
      }
    }
  }
  
  # Если имя контейнера еще не установлено, используем lookup по container_id
  if !exists(.container_name) {
    if exists(.container_id) {
      container_id_str, container_id_err = string(.container_id)
      if container_id_err == null && container_id_str != null {
        # Простой lookup по первым 12 символам container_id через match
        if match(container_id_str, r'^3c5237beb348') != null {
          .container_name = "gafus-web"
        } else if match(container_id_str, r'^8cfae0f4ff0b') != null {
          .container_name = "gafus-worker"
        } else if match(container_id_str, r'^1213f3d40db3') != null {
          .container_name = "gafus-trainer-panel"
        } else if match(container_id_str, r'^feebad0742eb') != null {
          .container_name = "gafus-error-dashboard"
        } else if match(container_id_str, r'^ae4acc8e2d25') != null {
          .container_name = "gafus-admin-panel"
        } else if match(container_id_str, r'^91a66f1b2704') != null {
          .container_name = "gafus-telegram-bot"
        } else if match(container_id_str, r'^267e9558e3a1') != null {
          .container_name = "gafus-seq"
        } else if match(container_id_str, r'^8b72ebf8555c') != null {
          .container_name = "gafus-postgres"
        } else if match(container_id_str, r'^0ed9ceae22b4') != null {
          .container_name = "gafus-redis"
        } else {
          .container_name = "container-" + container_id_str
        }
      }
    }
    
    # docker_logs source уже предоставил container_name в метаданных
  # Если имя все еще не установлено (fallback для старых логов или ошибок), используем container_id
  if !exists(.container_name) && exists(.container_id) {
    container_id_str, container_id_err = string(.container_id)
    if container_id_err == null && container_id_str != null {
      .container_name = "container-" + container_id_str
    }
  }
  }
  
  # Финальный fallback
  if !exists(.container_name) {
    .container_name = "unknown"
  }
'''

# Преобразуем данные в CLEF формат для Seq
[transforms.format_for_seq]
type = "remap"
inputs = ["add_container_name"]
source = '''
  # Преобразуем level в формат Seq
  seq_level = "Information"
  if .level == "trace" {
    seq_level = "Verbose"
  } else if .level == "debug" {
    seq_level = "Debug"
  } else if .level == "info" {
    seq_level = "Information"
  } else if .level == "warn" {
    seq_level = "Warning"
  } else if .level == "error" {
    seq_level = "Error"
  } else if .level == "fatal" {
    seq_level = "Fatal"
  }
  
  # Формируем CLEF JSON строку вручную (VRL не поддерживает объекты с @ ключами напрямую)
  clef_timestamp = if exists(.timestamp_str) && .timestamp_str != null { string!(.timestamp_str) } else { string!(now()) }
  clef_message = if exists(.msg) && .msg != null { string!(.msg) } else { "No message" }
  
  # Экранируем сообщение для JSON (заменяем специальные символы)
  clef_message_escaped = replace(clef_message, "\\", "\\\\")
  clef_message_escaped = replace(clef_message_escaped, "\"", "\\\"")
  clef_message_escaped = replace(clef_message_escaped, "\n", "\\n")
  clef_message_escaped = replace(clef_message_escaped, "\r", "\\r")
  clef_message_escaped = replace(clef_message_escaped, "\t", "\\t")
  
  # Формируем базовую CLEF JSON строку
  clef_json = "{\"@t\":\"" + clef_timestamp + "\",\"@m\":\"" + clef_message_escaped + "\",\"@l\":\"" + seq_level + "\""
  
  # Добавляем дополнительные свойства
  if exists(.container_id) && .container_id != null {
    clef_json = clef_json + ",\"ContainerId\":\"" + string!(.container_id) + "\""
  }
  if exists(.container_name) && .container_name != null {
    container_name_escaped = string!(.container_name)
    container_name_escaped = replace(container_name_escaped, "\\", "\\\\")
    container_name_escaped = replace(container_name_escaped, "\"", "\\\"")
    clef_json = clef_json + ",\"ContainerName\":\"" + container_name_escaped + "\""
  }
  if exists(.stream) && .stream != null {
    clef_json = clef_json + ",\"Stream\":\"" + string!(.stream) + "\""
  }
  if exists(.app) && .app != null {
    clef_json = clef_json + ",\"App\":\"" + string!(.app) + "\""
  }
  if exists(.context) && .context != null {
    clef_json = clef_json + ",\"Context\":\"" + string!(.context) + "\""
  }
  if exists(.stack) && .stack != null {
    stack_str = string!(.stack)
    stack_escaped = replace(stack_str, "\\", "\\\\")
    stack_escaped = replace(stack_escaped, "\"", "\\\"")
    stack_escaped = replace(stack_escaped, "\n", "\\n")
    stack_escaped = replace(stack_escaped, "\r", "\\r")
    stack_escaped = replace(stack_escaped, "\t", "\\t")
    clef_json = clef_json + ",\"Exception\":\"" + stack_escaped + "\""
  }
  if exists(.environment) && .environment != null {
    clef_json = clef_json + ",\"Environment\":\"" + string!(.environment) + "\""
  }
  
  # Завершаем JSON объект
  clef_json = clef_json + "}"
  
  # Используем CLEF JSON строку как текстовое сообщение
  # Vector автоматически разделит события новой строкой при батчинге для text codec
  . = {"message": clef_json}
'''

# Отправляем в Seq через CLEF формат
[sinks.seq]
type = "http"
inputs = ["format_for_seq"]
uri = "http://seq:80/api/events/raw?clef"
method = "post"

[sinks.seq.encoding]
codec = "text"
only_fields = ["message"]

[sinks.seq.request]
  [sinks.seq.request.headers]
  Content-Type = "application/vnd.serilog.clef"

# Настройки батчинга
# Vector автоматически разделяет события новой строкой для text codec
[sinks.seq.batch]
max_bytes = 10485760
max_events = 100
timeout_secs = 5
