---
alwaysApply: true
---

# Error Handling Best Practices

## Error Handling Strategy
- Use try-catch for all async operations
- Return structured errors: `{ success: false, error: string }`
- Log errors with `@gafus/logger`
- Report critical errors to error dashboard

## Logger Usage
```typescript
import { createWebLogger } from "@gafus/logger";

const logger = createWebLogger('feature-name');

logger.info("Operation started", { userId });
logger.success("Operation completed", { result });
logger.warn("Potential issue", { details });
logger.error("Operation failed", error as Error, { context });
```

## Server Actions Error Handling
```typescript
"use server";

import { createWebLogger } from "@gafus/logger";

const logger = createWebLogger('action-name');

export async function myAction(data: FormData) {
  try {
    // ... operation
    logger.success("Action completed");
    return { success: true };
  } catch (error) {
    logger.error("Action failed", error as Error, { action: "myAction" });
    return {
      success: false,
      error: error instanceof Error ? error.message : "Неизвестная ошибка"
    };
  }
}
```
Критичные ошибки при настроенных `ENABLE_ERROR_DASHBOARD` и `ERROR_DASHBOARD_URL` автоматически отправляются в error-dashboard через транспорт логгера (@gafus/logger). Отдельный вызов reportError не нужен.

## Client-Side Error Handling
- Показывать пользователю сообщения через state (`error`, `setError`)
- Проверять `result.success` / `result.error` из server actions
- Не показывать внутренние детали ошибок
- Сообщения пользователю — на русском

## Best Practices
- Never expose internal error details to users
- Always log errors with context
- Use specific error messages for debugging
- Handle network errors gracefully
- Provide user-friendly error messages
