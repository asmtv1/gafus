---
alwaysApply: true
---

# Testing Best Practices

## Testing Strategy
- Unit tests for utilities and helpers
- Integration tests for API routes and Server Actions
- E2E tests for critical user flows
- Test error scenarios

## Test Structure
```typescript
describe("Feature Name", () => {
  beforeEach(() => {
    // Setup
  });

  afterEach(() => {
    // Cleanup
  });

  it("should do something", () => {
    // Arrange
    const input = "test";
    
    // Act
    const result = myFunction(input);
    
    // Assert
    expect(result).toBe("expected");
  });
});
```

## Server Action Testing
```typescript
import { myAction } from "./myAction";

describe("myAction", () => {
  it("should return success for valid input", async () => {
    const formData = new FormData();
    formData.append("name", "Test");
    
    const result = await myAction(formData);
    
    expect(result.success).toBe(true);
  });

  it("should return error for invalid input", async () => {
    const formData = new FormData();
    
    const result = await myAction(formData);
    
    expect(result.error).toBeDefined();
  });
});
```

## Database Testing
- Use test database
- Clean up after each test
- Use transactions for isolation
- Mock external services

## Best Practices
- Write tests before fixing bugs
- Test edge cases and error paths
- Keep tests fast and isolated
- Use descriptive test names
- Mock external dependencies
- Aim for high coverage on critical paths
