---
alwaysApply: true
---

# TypeScript Best Practices

## Type Safety
- Always use explicit types for function parameters and return values
- Prefer `interface` for object types, `type` for unions/intersections
- Use **Discriminated Unions** for type-safe variants (e.g., `type: 'step' | 'immediate'`)
- Avoid `any` - use `unknown` or proper types instead
- Use `const assertions` for literal types

## Naming Conventions
- PascalCase for types, interfaces, classes, components
- camelCase for variables, functions, methods
- UPPER_SNAKE_CASE for constants
- Prefix interfaces with descriptive names (e.g., `UserData`, not `IUser`)

## Best Practices
- Use TypeScript 5.8+ features
- Enable strict mode in tsconfig.json
- Use optional chaining (`?.`) and nullish coalescing (`??`)
- Prefer `unknown` over `any` for type-safe error handling
- Use generics for reusable type-safe code

## Example: Discriminated Union
```typescript
// ✅ Good - Type-safe with discriminated union
type NotificationData = 
  | { type: 'step'; stepTitle: string; stepIndex: number }
  | { type: 'immediate'; title: string; body: string };

// ❌ Bad - Using magic numbers
type NotificationData = { stepIndex: number }; // -1 means immediate
```
